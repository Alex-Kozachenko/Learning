using "2023.04.05";
using "AdamFreeman.AspNetCore6.Chapter13"; // Using URL Routing.

//////////////////////////////////////////////////////////////////////
// Understanding URL Routing (11:30)

// Each Middleware Component decides to act in pipeline or not.
// The decision is made from the Request state, like
// - specific header;
// - query string value.
// But most components,
//  (especially terminals and short-circuiting components),
//  are trying to match the URL.

// Lets take a look on a pair of middleware 
//  which either tells about the capital of the country
//  or about the population of the city.

class Population
{
	RequestDelegate? next;
	public Population() { }	
	public Population(RequestDelegate next) { this.next = next; }
	public async Task Invoke(HttpContext context)
	{
		if (!TryProcessPopulation(context))
		{
			await next?.Invoke(context);
		}		
	}
	
	bool TryProcessPopulation(HttpContext context)
	{
		var parts = context.Request.Path
			.ToString()
			.Split("/", StringSplitOptions.RemoveEmptyEntries);
			
		if (parts.Length != 2)
			return false;
			
		var (segment, city) = (parts[0], parts[1]);
		
		if (segment != "population")
			return false;
		
		int? pop = city.ToLower() switch
		{
			"london" => 8_136_000,
			"paris" => 2_141_000,
			"monaco" => 39_000,
		};
		
		if (pop == null)
			return false;
			
		await context.Response
			.WriteAsync($"City: {city}, Population: {pop}");
		return true;
	}	
}

class Capital
{
	RequestDelegate? next;
	public Capital() { };
	public Capital(RequestDelegate next) { this.next = next; }
	public async Task Invoke(HttpContext context)
	{
		if (!TryProcessCapital(context))
		{
			await next?.Invoke(context);
		}
	}
	bool TryProcessCapital(HttpContext context)
	{
		var parts = context.Request.Path
			.ToString()
			.Split("/", StringSplitOptions.RemoveEmptyEntries);
			
		if (parts.Length != 2)
			return false;
			
		var (segment, country) = (parts[0], parts[1]);
		
		if (segment != "capital")
			return false;
		
		string? capital = country.ToLower() switch
		{
			"uk" => "London",
			"france" => "Paris",
			// WTF ?
			"monaco" => context.Response.Redirect($"/population/{country}"),
		};
		
		if (capital == null)
			return false;
		
		await context.Response
			.WriteAsync($"{capital} is the capital of the {country}.");
		return true;
	}
}

// OUTPUT:
//
// /population/london => City: london, population: 813...
// /capital/france => Paris is the capital of France

// The problem here that this common work 
//  is need to be done manually
//	and leads to a confusive paths really fast (see monaco).
// So here goes the URL Routing system 
// - a proxy-middleware which decides
//   which terminal or short-circuit to take.

// THE PROCESS OF ROUTUNG
//
// The `Routing Middleware`
//  -> processes the `URL`,
//  -> inspects the set of `routes`,
//  -> and finds the `endpoint` to handle the request. 

// The `Routing Middleware` is added 
//  using two separated methods:
//  - UseRouting 		-> Adds the middleware, responsible for processing the requests to the pipeline.
//	- UseEndpoints	-> Used to define the routes that match URLs to endpoints.

// The Routing Middleware 
//  enforces the inner Middleware Component 
//  to be the Terminal
//  by wrapping itself around, 
//  and making a short-circuit technique.
// If the request doesnt match any route,
//  then it is forwarded further down
//  to the terminal middleware.

// enable the Routing Middleware (the Holy Dispatcher).
app.UseRouting();

// routing middleware here:
app.UseEndpoints(endpoints => 
{
	var path = "routing"; // whithout leading / which isn't the URL path.
	endpoints.MapGet(path, async ctx => { await context.Response.WriteAsync("Request was routed. Hello Endpoint!"); }); 
});

// regular stuff here:
app.Run(context => context.Response.WriteAsync("Hello unrouted Terminal!");
app.Run();

// OUTPUT:
//
// /routing => Request was routed. Hello Endpoint!
// /someother => Hello unrouted Terminal!

// Auto-enable UseRouting.
// 
// The platform has the routing enabled already, so the app.MapGet works as well:
app.MapGet("routing", async ctx => ctx.Response.WriteAsync("Routed"));

// Hovewer, the Endpoints aren't short-circuited anymore,
//  so the terminal will be triggered anyway:

app.MapGet("routing", async ctx => ctx.Response.WriteAsync("Routed"));
app.Run(async ctx => ctx.Response.WriteAsync("Terminal"));
// OUTPUT: 
// Routed. Terminal.

// A bug or feature?
// So, the previous part states that
//  there is a difference between
//  building the endpoints via
//  - nested UseEndpoints 
//  - and app.MapGet directly.
//
// The diff lays that 
//   app-Routes are layered together with 
//    the Terminal on app-layer.
// while the UseEndpoints
//  is able to make a sublayer 
//  which short-circuites the pipeline processing
// 
// IMO, its a glitch by design, like 
//  the `app` cant build a wrapper around the `Endpoint`, 
//  like the `.UseEndpoint` does.
//
// It leads to a confusion - 
//  the app-Route-Endpoint is not an Endpoint in its true meaning.
//  So its a glitch by design

//////////////////////////////////////////////////////////////////////
// Understanding URL Patterns (15:00)

// If you write a route MapGet("capital/uk")
//  is a legit hardcode and will work if only:
//  1. there are two segments
//  2. the first is "capital" 
//     and the second is "uk"
//
// /capital/uk 					-> yes
// /capital 						-> no, too few segments
// /capital/europe/uk		-> no, too many segments
// /name/uk							-> no, first segment != "capital"
//
// So, itall a literal segments which
//  wont work for variables.

// How to declare a routing with variable segments?
//
// The same sections but any content looks like:
//  /{first}/{second} 	-> yes, for any two-segmented path.
//
// All segment variables are available in the `HttpContext.RouteValues` dictionary.

//////////////////////////////////////////////////////////////////////
// Understanding Route Selection
//
// When the Routing system decides which endpoint gonna process the URL
//  it gives the suitability-scores for all endpoints.
// The lowest score wins.
// Two lowest scores trigger AmbigousRouteException.
// The scoring algorithm could differ, but the common sense is 
// - the more specific, the better.

//////////////////////////////////////////////////////////////////////
// Refactoring Middleware into an Endpoint

class Capital 
{
	public static async Task Endpoint(HttpContext context)
	{
		// Middleware components can be used as endpoints.
		// But not the opposite.
		// Here is the dependency on the Routing system:
		var country = context.Request.RouteValues["country"] as string;
		country = country?.ToLower() ?? "";
		var capital = country switch 
		{
			"uk" -> "London",
			"france" -> "Paris",
			"monaco" -> context.Response.Redirect($"/population/country");
		};
		
		if (capital is not null)
		{
			await context.Response.WriteAsync($"{capital} is the capital of the {country}");
		}
		else
		{
			context.Response.StatusCode = StatusCodes.Status404NotFound;
		}
	}
}

class Population
{
	public static async Task Endpoint(HttpContext context)
	{
		var city = context.Request.RouteValues["city"] as string;
		int? pop = city switch 
		{
			"london" -> 8_136_000,
			"paris" -> 2_141_000,
			"monaco" -> 39_000
		};
		
		if (pop.HasValue)
		{
			await context.Response.WriteAsync($"City: {city}, Population: {pop}");
		}
		else
		{
			context.Response.StatusCode = StatusCodes = Status404NotFound;
		}
	}
}

app.MapGet("capital/{country}", Capital.Endpoint);
app.MapGet("population/{city}", Population.Endpoint);

app.Run();

//////////////////////////////////////////////////////////////////////
// Generating URLs from Routes (15:25)

// Supplying the data-values 
//  for segment variables
//  in routing system,
//  allows to make a named route.

var theRouteName = "population";
app.MapGet("population/{city}", Population.Endpoint)
	.WithMetadata(new RouteMetadata(theRouteName));
	
...
"monaco" -> 
{
	var generator = context.RequestServices.GetService<LinkGenerator>();
	var url = generator?.GetPathByRouteValues(context, theRouteName, new { city = "monaco" });
	if (url is not null)
		context.Response.Redirect(url);
}
...

//////////////////////////////////////////////////////////////////////
// Managing URL matching (17:00)

// In case if previous features arent sufficient,
//  there are more cases for precise routing.

// A URL pattern can contain as many segment variables,
//  as you need, as long as they are separated
//  by static string.
app.MagGet("files/{filename}.{ext}") // files/file.txt

// Default values:
app.MapGet("capital/{country=France");

// Optional segments:
app.MapGet("size/{city?}"); // could be NULL.

// Catch all
//
// While optional segments allow to match shorter URLs,
//  the catchall, allows to match longer URLs
app.MapGet("{first}/{second}/{*catchall}"}); // some/long/url/doesnt/really/matter -> two segments and catchall = url/doesnt/...

// Constraints
//
// The route could be configured to check the datatype.
// If the types arent met - this route is ignored.
app.MapGet("{first:int}/{second:bool}"); // 100/true -> ok. true/100 -> no.
//
// There are also really advanced filters:
app.MapGet("{first:alpha:length(3)})"); // dog/  -> ok. dogs/ -> no.
//
// Or limit a segment to specific values, 
// via regex:
app.MapGet("capital/{country:regex(^uk|france|monaco$)}"); // capital/uk -> ok. capital/japan -> no.

// Fallback routes
// 
// Works if no other route matches a request.
// Prevents requests from being passed
//  further along the request pipeline
//  by ensuring that the routing system
//  will always generate a response.
app.MapFallback(async ctx => { await context.Response.WriteAsync("Routed to fallback endpoint"); });


//////////////////////////////////////////////////////////////////////
// Advanced Routing Features

// The routing capabilities described above
//  shoud be enough for most cases
//  especially for asp.net MVC
// However, there are some more
//  advanced features.

// Custom Constraints
//  via IRouteConstraint
class CountryRouteConstraint : IRouteConstraint
{
	string[] countries = { "uk", "france", "monaco" };
	
	public bool Match(
		HttpContext? httpContext,
		IRouter? route,
		string routeKey,
		RouteValueDictionary values,
		RouteDirection direction)
	{
		var segmentValue = values[routeKey] as string ?? "";
		return Array.IndexOf(countries, segmentValue.ToLower()) > -1;
	}
}

builder.Services.Configure<RouteOptions> (opts => 
{
	opts.ConstraintMap.Add("countryName", typeof(CountryRouteConstraint));
});
app.MapGet("capital/{country:countryName}", Capital.Endpoint);

// Avoid Ambiguous Route Exceptions
//
// If two routes has a same score,
//  the routing system cant tell which to pick
//  so use Order property
app.Map("{number:int}", ...).Add(b => ((RouteEndpointBuilder)b).Order = 1);
app.Map("{number:double}", ...).Add(b => ((RouteEndpointBuilder)b).Order = 2);

// Accessing the Endpoint in a Middleware Component
//
// Normally, the Middleware components dont know
//  who gonna be called later.
// Hovewer, the Routing Middleware has access to an Enpoint
//  which has been chosen
//  but the pipeline have not been triggered yet.
var app = builder.Build();
app.Use(async (context, next) => 
{
	var endpoint = context.GetEndpoint();
	if (end != null)
	{
		await context.Response.WriteAsync($"{end.DisplayName} selected \n");
	}
	else
	{
		await context.Response.WriteAsync("No Endpoint Selected \n");
	}
	await next();
});

app.Map("{number:int}"...).WithDisplayName("Int Endpoint").Add(b => b.Order = 1)
app.Map("{number:double}"...).WithDisplayName("Double Endpoint").Add(b => b.Order = 2);

// Done at 18:13
/////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

